% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/env.r
\name{namespace}
\alias{namespace}
\alias{make_namespace}
\alias{is_namespace}
\alias{namespace_info}
\alias{namespace_info<-}
\alias{mod_topenv}
\alias{is_mod_topenv}
\title{Module namespace handling}
\usage{
make_namespace(info)

is_namespace(env)

namespace_info(ns, which, default = NULL)

namespace_info(ns, which) <- value

mod_topenv(env = parent.frame())

is_mod_topenv(env)
}
\arguments{
\item{info}{the module info.}

\item{env}{an environment that may be a module namespace.}

\item{ns}{the module namespace environment.}

\item{which}{the key (as a length 1 character string) of the info to get/set.}

\item{default}{default value to use if the key is not set.}

\item{value}{the value to assign to the specified key.}
}
\value{
\code{make_namespace} returns the newly created module namespace for
the module described by \code{info}.
}
\description{
\code{make_namespace} creates a new module namespace.
}
\details{
The namespace contains a module’s content. This schema is very much like R
package organisation. A good resource for this is:
<http://obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/>
}
\note{
Module namespaces aren’t actual R package namespaces. This is
intentional, since R makes strong assumptions about package namespaces that
are violated here. In particular, such namespaces would have to be registered
in R’s internal namespace registry, and their (de)serialisation is handled by
R code which assumes that they belong to actual packges that can be loaded
via `loadNamespace`.
}
\keyword{internal}
